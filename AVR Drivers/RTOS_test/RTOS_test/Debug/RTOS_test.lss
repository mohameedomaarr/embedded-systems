
RTOS_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c9a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00000c9a  00000d2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000063e  0080006a  0080006a  00000d38  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d38  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d68  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000240  00000000  00000000  00000da4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000025d8  00000000  00000000  00000fe4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b84  00000000  00000000  000035bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001666  00000000  00000000  00004140  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006bc  00000000  00000000  000057a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e46  00000000  00000000  00005e64  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001ff0  00000000  00000000  00006caa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00008c9a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 87 02 	jmp	0x50e	; 0x50e <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e9       	ldi	r30, 0x9A	; 154
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 36       	cpi	r26, 0x6A	; 106
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	aa e6       	ldi	r26, 0x6A	; 106
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 3a       	cpi	r26, 0xA8	; 168
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 13 01 	call	0x226	; 0x226 <main>
  8a:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  98:	0e 94 a7 04 	call	0x94e	; 0x94e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  9c:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
  a0:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <__data_end+0x1>
  a4:	89 2b       	or	r24, r25
  a6:	31 f4       	brne	.+12     	; 0xb4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  a8:	8f e6       	ldi	r24, 0x6F	; 111
  aa:	90 e0       	ldi	r25, 0x00	; 0
  ac:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <__data_end+0x1>
  b0:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  b4:	20 91 6c 00 	lds	r18, 0x006C	; 0x80006c <xNextFreeByte>
  b8:	30 91 6d 00 	lds	r19, 0x006D	; 0x80006d <xNextFreeByte+0x1>
  bc:	c9 01       	movw	r24, r18
  be:	8c 0f       	add	r24, r28
  c0:	9d 1f       	adc	r25, r29
  c2:	8b 3d       	cpi	r24, 0xDB	; 219
  c4:	45 e0       	ldi	r20, 0x05	; 5
  c6:	94 07       	cpc	r25, r20
  c8:	70 f4       	brcc	.+28     	; 0xe6 <pvPortMalloc+0x54>
  ca:	28 17       	cp	r18, r24
  cc:	39 07       	cpc	r19, r25
  ce:	70 f4       	brcc	.+28     	; 0xec <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  d0:	c0 91 6a 00 	lds	r28, 0x006A	; 0x80006a <__data_end>
  d4:	d0 91 6b 00 	lds	r29, 0x006B	; 0x80006b <__data_end+0x1>
  d8:	c2 0f       	add	r28, r18
  da:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
  dc:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <xNextFreeByte+0x1>
  e0:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <xNextFreeByte>
  e4:	05 c0       	rjmp	.+10     	; 0xf0 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
  e6:	c0 e0       	ldi	r28, 0x00	; 0
  e8:	d0 e0       	ldi	r29, 0x00	; 0
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <pvPortMalloc+0x5e>
  ec:	c0 e0       	ldi	r28, 0x00	; 0
  ee:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  f0:	0e 94 6b 05 	call	0xad6	; 0xad6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
  f4:	ce 01       	movw	r24, r28
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  fc:	08 95       	ret

000000fe <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  fe:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 100:	03 96       	adiw	r24, 0x03	; 3
 102:	92 83       	std	Z+2, r25	; 0x02
 104:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 106:	2f ef       	ldi	r18, 0xFF	; 255
 108:	3f ef       	ldi	r19, 0xFF	; 255
 10a:	34 83       	std	Z+4, r19	; 0x04
 10c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 10e:	96 83       	std	Z+6, r25	; 0x06
 110:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 112:	90 87       	std	Z+8, r25	; 0x08
 114:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 116:	10 82       	st	Z, r1
 118:	08 95       	ret

0000011a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 11a:	fc 01       	movw	r30, r24
 11c:	11 86       	std	Z+9, r1	; 0x09
 11e:	10 86       	std	Z+8, r1	; 0x08
 120:	08 95       	ret

00000122 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 122:	cf 93       	push	r28
 124:	df 93       	push	r29
 126:	9c 01       	movw	r18, r24
 128:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 12a:	dc 01       	movw	r26, r24
 12c:	11 96       	adiw	r26, 0x01	; 1
 12e:	cd 91       	ld	r28, X+
 130:	dc 91       	ld	r29, X
 132:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 134:	d3 83       	std	Z+3, r29	; 0x03
 136:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 138:	8c 81       	ldd	r24, Y+4	; 0x04
 13a:	9d 81       	ldd	r25, Y+5	; 0x05
 13c:	95 83       	std	Z+5, r25	; 0x05
 13e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 140:	8c 81       	ldd	r24, Y+4	; 0x04
 142:	9d 81       	ldd	r25, Y+5	; 0x05
 144:	dc 01       	movw	r26, r24
 146:	13 96       	adiw	r26, 0x03	; 3
 148:	7c 93       	st	X, r23
 14a:	6e 93       	st	-X, r22
 14c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 14e:	7d 83       	std	Y+5, r23	; 0x05
 150:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 152:	31 87       	std	Z+9, r19	; 0x09
 154:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 156:	f9 01       	movw	r30, r18
 158:	80 81       	ld	r24, Z
 15a:	8f 5f       	subi	r24, 0xFF	; 255
 15c:	80 83       	st	Z, r24
}
 15e:	df 91       	pop	r29
 160:	cf 91       	pop	r28
 162:	08 95       	ret

00000164 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 164:	cf 93       	push	r28
 166:	df 93       	push	r29
 168:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 16a:	48 81       	ld	r20, Y
 16c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 16e:	4f 3f       	cpi	r20, 0xFF	; 255
 170:	2f ef       	ldi	r18, 0xFF	; 255
 172:	52 07       	cpc	r21, r18
 174:	21 f4       	brne	.+8      	; 0x17e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 176:	fc 01       	movw	r30, r24
 178:	a7 81       	ldd	r26, Z+7	; 0x07
 17a:	b0 85       	ldd	r27, Z+8	; 0x08
 17c:	0d c0       	rjmp	.+26     	; 0x198 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 17e:	dc 01       	movw	r26, r24
 180:	13 96       	adiw	r26, 0x03	; 3
 182:	01 c0       	rjmp	.+2      	; 0x186 <vListInsert+0x22>
 184:	df 01       	movw	r26, r30
 186:	12 96       	adiw	r26, 0x02	; 2
 188:	ed 91       	ld	r30, X+
 18a:	fc 91       	ld	r31, X
 18c:	13 97       	sbiw	r26, 0x03	; 3
 18e:	20 81       	ld	r18, Z
 190:	31 81       	ldd	r19, Z+1	; 0x01
 192:	42 17       	cp	r20, r18
 194:	53 07       	cpc	r21, r19
 196:	b0 f7       	brcc	.-20     	; 0x184 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 198:	12 96       	adiw	r26, 0x02	; 2
 19a:	ed 91       	ld	r30, X+
 19c:	fc 91       	ld	r31, X
 19e:	13 97       	sbiw	r26, 0x03	; 3
 1a0:	fb 83       	std	Y+3, r31	; 0x03
 1a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1a4:	d5 83       	std	Z+5, r29	; 0x05
 1a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1a8:	bd 83       	std	Y+5, r27	; 0x05
 1aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1ac:	13 96       	adiw	r26, 0x03	; 3
 1ae:	dc 93       	st	X, r29
 1b0:	ce 93       	st	-X, r28
 1b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 1b4:	99 87       	std	Y+9, r25	; 0x09
 1b6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1b8:	fc 01       	movw	r30, r24
 1ba:	20 81       	ld	r18, Z
 1bc:	2f 5f       	subi	r18, 0xFF	; 255
 1be:	20 83       	st	Z, r18
}
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	08 95       	ret

000001c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1c6:	cf 93       	push	r28
 1c8:	df 93       	push	r29
 1ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 1cc:	a0 85       	ldd	r26, Z+8	; 0x08
 1ce:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1d0:	c2 81       	ldd	r28, Z+2	; 0x02
 1d2:	d3 81       	ldd	r29, Z+3	; 0x03
 1d4:	84 81       	ldd	r24, Z+4	; 0x04
 1d6:	95 81       	ldd	r25, Z+5	; 0x05
 1d8:	9d 83       	std	Y+5, r25	; 0x05
 1da:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1dc:	c4 81       	ldd	r28, Z+4	; 0x04
 1de:	d5 81       	ldd	r29, Z+5	; 0x05
 1e0:	82 81       	ldd	r24, Z+2	; 0x02
 1e2:	93 81       	ldd	r25, Z+3	; 0x03
 1e4:	9b 83       	std	Y+3, r25	; 0x03
 1e6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1e8:	11 96       	adiw	r26, 0x01	; 1
 1ea:	8d 91       	ld	r24, X+
 1ec:	9c 91       	ld	r25, X
 1ee:	12 97       	sbiw	r26, 0x02	; 2
 1f0:	e8 17       	cp	r30, r24
 1f2:	f9 07       	cpc	r31, r25
 1f4:	31 f4       	brne	.+12     	; 0x202 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1f6:	84 81       	ldd	r24, Z+4	; 0x04
 1f8:	95 81       	ldd	r25, Z+5	; 0x05
 1fa:	12 96       	adiw	r26, 0x02	; 2
 1fc:	9c 93       	st	X, r25
 1fe:	8e 93       	st	-X, r24
 200:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 202:	11 86       	std	Z+9, r1	; 0x09
 204:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 206:	8c 91       	ld	r24, X
 208:	81 50       	subi	r24, 0x01	; 1
 20a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
 20c:	8c 91       	ld	r24, X
}
 20e:	df 91       	pop	r29
 210:	cf 91       	pop	r28
 212:	08 95       	ret

00000214 <LED>:
}

void LED( void * pv){
	  while (1)
	  {
		  PORTC ^= (1<<2);
 214:	95 b3       	in	r25, 0x15	; 21
 216:	84 e0       	ldi	r24, 0x04	; 4
 218:	89 27       	eor	r24, r25
 21a:	85 bb       	out	0x15, r24	; 21
		  vTaskDelay(500/portTICK_PERIOD_MS);
 21c:	84 ef       	ldi	r24, 0xF4	; 244
 21e:	91 e0       	ldi	r25, 0x01	; 1
 220:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <vTaskDelay>
 224:	f7 cf       	rjmp	.-18     	; 0x214 <LED>

00000226 <main>:
#include "FreeRTOS.h"
#include "task.h"
void LED( void * pv);

int main(void)
{
 226:	cf 93       	push	r28
 228:	df 93       	push	r29
 22a:	00 d0       	rcall	.+0      	; 0x22c <main+0x6>
 22c:	cd b7       	in	r28, 0x3d	; 61
 22e:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xHandle = NULL;
 230:	1a 82       	std	Y+2, r1	; 0x02
 232:	19 82       	std	Y+1, r1	; 0x01
	DDRC |= (1<<2);
 234:	84 b3       	in	r24, 0x14	; 20
 236:	84 60       	ori	r24, 0x04	; 4
 238:	84 bb       	out	0x14, r24	; 20
    xTaskCreate(LED,"LED",50,NULL,1,&xHandle);
 23a:	ce 01       	movw	r24, r28
 23c:	01 96       	adiw	r24, 0x01	; 1
 23e:	7c 01       	movw	r14, r24
 240:	01 e0       	ldi	r16, 0x01	; 1
 242:	20 e0       	ldi	r18, 0x00	; 0
 244:	30 e0       	ldi	r19, 0x00	; 0
 246:	42 e3       	ldi	r20, 0x32	; 50
 248:	50 e0       	ldi	r21, 0x00	; 0
 24a:	60 e6       	ldi	r22, 0x60	; 96
 24c:	70 e0       	ldi	r23, 0x00	; 0
 24e:	8a e0       	ldi	r24, 0x0A	; 10
 250:	91 e0       	ldi	r25, 0x01	; 1
 252:	0e 94 29 04 	call	0x852	; 0x852 <xTaskCreate>
	vTaskStartScheduler();
 256:	0e 94 7d 04 	call	0x8fa	; 0x8fa <vTaskStartScheduler>
 25a:	ff cf       	rjmp	.-2      	; 0x25a <main+0x34>

0000025c <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 25c:	1b bc       	out	0x2b, r1	; 43
 25e:	89 ef       	ldi	r24, 0xF9	; 249
 260:	8a bd       	out	0x2a, r24	; 42
 262:	8b e0       	ldi	r24, 0x0B	; 11
 264:	8e bd       	out	0x2e, r24	; 46
 266:	89 b7       	in	r24, 0x39	; 57
 268:	80 61       	ori	r24, 0x10	; 16
 26a:	89 bf       	out	0x39, r24	; 57
 26c:	08 95       	ret

0000026e <pxPortInitialiseStack>:
 26e:	31 e1       	ldi	r19, 0x11	; 17
 270:	fc 01       	movw	r30, r24
 272:	30 83       	st	Z, r19
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	22 e2       	ldi	r18, 0x22	; 34
 278:	20 83       	st	Z, r18
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	a3 e3       	ldi	r26, 0x33	; 51
 27e:	a0 83       	st	Z, r26
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	60 83       	st	Z, r22
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	70 83       	st	Z, r23
 288:	31 97       	sbiw	r30, 0x01	; 1
 28a:	10 82       	st	Z, r1
 28c:	31 97       	sbiw	r30, 0x01	; 1
 28e:	60 e8       	ldi	r22, 0x80	; 128
 290:	60 83       	st	Z, r22
 292:	31 97       	sbiw	r30, 0x01	; 1
 294:	10 82       	st	Z, r1
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	62 e0       	ldi	r22, 0x02	; 2
 29a:	60 83       	st	Z, r22
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	63 e0       	ldi	r22, 0x03	; 3
 2a0:	60 83       	st	Z, r22
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	64 e0       	ldi	r22, 0x04	; 4
 2a6:	60 83       	st	Z, r22
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	65 e0       	ldi	r22, 0x05	; 5
 2ac:	60 83       	st	Z, r22
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	66 e0       	ldi	r22, 0x06	; 6
 2b2:	60 83       	st	Z, r22
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	67 e0       	ldi	r22, 0x07	; 7
 2b8:	60 83       	st	Z, r22
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	68 e0       	ldi	r22, 0x08	; 8
 2be:	60 83       	st	Z, r22
 2c0:	31 97       	sbiw	r30, 0x01	; 1
 2c2:	69 e0       	ldi	r22, 0x09	; 9
 2c4:	60 83       	st	Z, r22
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	60 e1       	ldi	r22, 0x10	; 16
 2ca:	60 83       	st	Z, r22
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	30 83       	st	Z, r19
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	32 e1       	ldi	r19, 0x12	; 18
 2d4:	30 83       	st	Z, r19
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	33 e1       	ldi	r19, 0x13	; 19
 2da:	30 83       	st	Z, r19
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	34 e1       	ldi	r19, 0x14	; 20
 2e0:	30 83       	st	Z, r19
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	35 e1       	ldi	r19, 0x15	; 21
 2e6:	30 83       	st	Z, r19
 2e8:	31 97       	sbiw	r30, 0x01	; 1
 2ea:	36 e1       	ldi	r19, 0x16	; 22
 2ec:	30 83       	st	Z, r19
 2ee:	31 97       	sbiw	r30, 0x01	; 1
 2f0:	37 e1       	ldi	r19, 0x17	; 23
 2f2:	30 83       	st	Z, r19
 2f4:	31 97       	sbiw	r30, 0x01	; 1
 2f6:	38 e1       	ldi	r19, 0x18	; 24
 2f8:	30 83       	st	Z, r19
 2fa:	31 97       	sbiw	r30, 0x01	; 1
 2fc:	39 e1       	ldi	r19, 0x19	; 25
 2fe:	30 83       	st	Z, r19
 300:	31 97       	sbiw	r30, 0x01	; 1
 302:	30 e2       	ldi	r19, 0x20	; 32
 304:	30 83       	st	Z, r19
 306:	31 97       	sbiw	r30, 0x01	; 1
 308:	31 e2       	ldi	r19, 0x21	; 33
 30a:	30 83       	st	Z, r19
 30c:	31 97       	sbiw	r30, 0x01	; 1
 30e:	20 83       	st	Z, r18
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	23 e2       	ldi	r18, 0x23	; 35
 314:	20 83       	st	Z, r18
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	40 83       	st	Z, r20
 31a:	31 97       	sbiw	r30, 0x01	; 1
 31c:	50 83       	st	Z, r21
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	26 e2       	ldi	r18, 0x26	; 38
 322:	20 83       	st	Z, r18
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	27 e2       	ldi	r18, 0x27	; 39
 328:	20 83       	st	Z, r18
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	28 e2       	ldi	r18, 0x28	; 40
 32e:	20 83       	st	Z, r18
 330:	31 97       	sbiw	r30, 0x01	; 1
 332:	29 e2       	ldi	r18, 0x29	; 41
 334:	20 83       	st	Z, r18
 336:	31 97       	sbiw	r30, 0x01	; 1
 338:	20 e3       	ldi	r18, 0x30	; 48
 33a:	20 83       	st	Z, r18
 33c:	31 97       	sbiw	r30, 0x01	; 1
 33e:	21 e3       	ldi	r18, 0x31	; 49
 340:	20 83       	st	Z, r18
 342:	86 97       	sbiw	r24, 0x26	; 38
 344:	08 95       	ret

00000346 <xPortStartScheduler>:
 346:	0e 94 2e 01 	call	0x25c	; 0x25c <prvSetupTimerInterrupt>
 34a:	a0 91 a6 06 	lds	r26, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 34e:	b0 91 a7 06 	lds	r27, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 352:	cd 91       	ld	r28, X+
 354:	cd bf       	out	0x3d, r28	; 61
 356:	dd 91       	ld	r29, X+
 358:	de bf       	out	0x3e, r29	; 62
 35a:	ff 91       	pop	r31
 35c:	ef 91       	pop	r30
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	bf 91       	pop	r27
 364:	af 91       	pop	r26
 366:	9f 91       	pop	r25
 368:	8f 91       	pop	r24
 36a:	7f 91       	pop	r23
 36c:	6f 91       	pop	r22
 36e:	5f 91       	pop	r21
 370:	4f 91       	pop	r20
 372:	3f 91       	pop	r19
 374:	2f 91       	pop	r18
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	ff 90       	pop	r15
 37c:	ef 90       	pop	r14
 37e:	df 90       	pop	r13
 380:	cf 90       	pop	r12
 382:	bf 90       	pop	r11
 384:	af 90       	pop	r10
 386:	9f 90       	pop	r9
 388:	8f 90       	pop	r8
 38a:	7f 90       	pop	r7
 38c:	6f 90       	pop	r6
 38e:	5f 90       	pop	r5
 390:	4f 90       	pop	r4
 392:	3f 90       	pop	r3
 394:	2f 90       	pop	r2
 396:	1f 90       	pop	r1
 398:	0f 90       	pop	r0
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	0f 90       	pop	r0
 39e:	08 95       	ret
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	08 95       	ret

000003a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	f8 94       	cli
 3aa:	0f 92       	push	r0
 3ac:	1f 92       	push	r1
 3ae:	11 24       	eor	r1, r1
 3b0:	2f 92       	push	r2
 3b2:	3f 92       	push	r3
 3b4:	4f 92       	push	r4
 3b6:	5f 92       	push	r5
 3b8:	6f 92       	push	r6
 3ba:	7f 92       	push	r7
 3bc:	8f 92       	push	r8
 3be:	9f 92       	push	r9
 3c0:	af 92       	push	r10
 3c2:	bf 92       	push	r11
 3c4:	cf 92       	push	r12
 3c6:	df 92       	push	r13
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	2f 93       	push	r18
 3d2:	3f 93       	push	r19
 3d4:	4f 93       	push	r20
 3d6:	5f 93       	push	r21
 3d8:	6f 93       	push	r22
 3da:	7f 93       	push	r23
 3dc:	8f 93       	push	r24
 3de:	9f 93       	push	r25
 3e0:	af 93       	push	r26
 3e2:	bf 93       	push	r27
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	ef 93       	push	r30
 3ea:	ff 93       	push	r31
 3ec:	a0 91 a6 06 	lds	r26, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 3f0:	b0 91 a7 06 	lds	r27, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 3f4:	0d b6       	in	r0, 0x3d	; 61
 3f6:	0d 92       	st	X+, r0
 3f8:	0e b6       	in	r0, 0x3e	; 62
 3fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3fc:	0e 94 f7 05 	call	0xbee	; 0xbee <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 400:	a0 91 a6 06 	lds	r26, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 404:	b0 91 a7 06 	lds	r27, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 408:	cd 91       	ld	r28, X+
 40a:	cd bf       	out	0x3d, r28	; 61
 40c:	dd 91       	ld	r29, X+
 40e:	de bf       	out	0x3e, r29	; 62
 410:	ff 91       	pop	r31
 412:	ef 91       	pop	r30
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	bf 91       	pop	r27
 41a:	af 91       	pop	r26
 41c:	9f 91       	pop	r25
 41e:	8f 91       	pop	r24
 420:	7f 91       	pop	r23
 422:	6f 91       	pop	r22
 424:	5f 91       	pop	r21
 426:	4f 91       	pop	r20
 428:	3f 91       	pop	r19
 42a:	2f 91       	pop	r18
 42c:	1f 91       	pop	r17
 42e:	0f 91       	pop	r16
 430:	ff 90       	pop	r15
 432:	ef 90       	pop	r14
 434:	df 90       	pop	r13
 436:	cf 90       	pop	r12
 438:	bf 90       	pop	r11
 43a:	af 90       	pop	r10
 43c:	9f 90       	pop	r9
 43e:	8f 90       	pop	r8
 440:	7f 90       	pop	r7
 442:	6f 90       	pop	r6
 444:	5f 90       	pop	r5
 446:	4f 90       	pop	r4
 448:	3f 90       	pop	r3
 44a:	2f 90       	pop	r2
 44c:	1f 90       	pop	r1
 44e:	0f 90       	pop	r0
 450:	0f be       	out	0x3f, r0	; 63
 452:	0f 90       	pop	r0

	asm volatile ( "ret" );
 454:	08 95       	ret

00000456 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 456:	0f 92       	push	r0
 458:	0f b6       	in	r0, 0x3f	; 63
 45a:	f8 94       	cli
 45c:	0f 92       	push	r0
 45e:	1f 92       	push	r1
 460:	11 24       	eor	r1, r1
 462:	2f 92       	push	r2
 464:	3f 92       	push	r3
 466:	4f 92       	push	r4
 468:	5f 92       	push	r5
 46a:	6f 92       	push	r6
 46c:	7f 92       	push	r7
 46e:	8f 92       	push	r8
 470:	9f 92       	push	r9
 472:	af 92       	push	r10
 474:	bf 92       	push	r11
 476:	cf 92       	push	r12
 478:	df 92       	push	r13
 47a:	ef 92       	push	r14
 47c:	ff 92       	push	r15
 47e:	0f 93       	push	r16
 480:	1f 93       	push	r17
 482:	2f 93       	push	r18
 484:	3f 93       	push	r19
 486:	4f 93       	push	r20
 488:	5f 93       	push	r21
 48a:	6f 93       	push	r22
 48c:	7f 93       	push	r23
 48e:	8f 93       	push	r24
 490:	9f 93       	push	r25
 492:	af 93       	push	r26
 494:	bf 93       	push	r27
 496:	cf 93       	push	r28
 498:	df 93       	push	r29
 49a:	ef 93       	push	r30
 49c:	ff 93       	push	r31
 49e:	a0 91 a6 06 	lds	r26, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 4a2:	b0 91 a7 06 	lds	r27, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 4a6:	0d b6       	in	r0, 0x3d	; 61
 4a8:	0d 92       	st	X+, r0
 4aa:	0e b6       	in	r0, 0x3e	; 62
 4ac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4ae:	0e 94 ad 04 	call	0x95a	; 0x95a <xTaskIncrementTick>
 4b2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4b4:	0e 94 f7 05 	call	0xbee	; 0xbee <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 4b8:	a0 91 a6 06 	lds	r26, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 4bc:	b0 91 a7 06 	lds	r27, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 4c0:	cd 91       	ld	r28, X+
 4c2:	cd bf       	out	0x3d, r28	; 61
 4c4:	dd 91       	ld	r29, X+
 4c6:	de bf       	out	0x3e, r29	; 62
 4c8:	ff 91       	pop	r31
 4ca:	ef 91       	pop	r30
 4cc:	df 91       	pop	r29
 4ce:	cf 91       	pop	r28
 4d0:	bf 91       	pop	r27
 4d2:	af 91       	pop	r26
 4d4:	9f 91       	pop	r25
 4d6:	8f 91       	pop	r24
 4d8:	7f 91       	pop	r23
 4da:	6f 91       	pop	r22
 4dc:	5f 91       	pop	r21
 4de:	4f 91       	pop	r20
 4e0:	3f 91       	pop	r19
 4e2:	2f 91       	pop	r18
 4e4:	1f 91       	pop	r17
 4e6:	0f 91       	pop	r16
 4e8:	ff 90       	pop	r15
 4ea:	ef 90       	pop	r14
 4ec:	df 90       	pop	r13
 4ee:	cf 90       	pop	r12
 4f0:	bf 90       	pop	r11
 4f2:	af 90       	pop	r10
 4f4:	9f 90       	pop	r9
 4f6:	8f 90       	pop	r8
 4f8:	7f 90       	pop	r7
 4fa:	6f 90       	pop	r6
 4fc:	5f 90       	pop	r5
 4fe:	4f 90       	pop	r4
 500:	3f 90       	pop	r3
 502:	2f 90       	pop	r2
 504:	1f 90       	pop	r1
 506:	0f 90       	pop	r0
 508:	0f be       	out	0x3f, r0	; 63
 50a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 50c:	08 95       	ret

0000050e <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 50e:	0e 94 2b 02 	call	0x456	; 0x456 <vPortYieldFromTick>
		asm volatile ( "reti" );
 512:	18 95       	reti

00000514 <prvResetNextTaskUnblockTime>:
	vTaskSuspendAll();
	xPendedTicks += xTicksToCatchUp;
	xYieldRequired = xTaskResumeAll();

	return xYieldRequired;
}
 514:	e0 91 6e 06 	lds	r30, 0x066E	; 0x80066e <pxDelayedTaskList>
 518:	f0 91 6f 06 	lds	r31, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 51c:	80 81       	ld	r24, Z
 51e:	81 11       	cpse	r24, r1
 520:	07 c0       	rjmp	.+14     	; 0x530 <prvResetNextTaskUnblockTime+0x1c>
 522:	8f ef       	ldi	r24, 0xFF	; 255
 524:	9f ef       	ldi	r25, 0xFF	; 255
 526:	90 93 4e 06 	sts	0x064E, r25	; 0x80064e <xNextTaskUnblockTime+0x1>
 52a:	80 93 4d 06 	sts	0x064D, r24	; 0x80064d <xNextTaskUnblockTime>
 52e:	08 95       	ret
 530:	e0 91 6e 06 	lds	r30, 0x066E	; 0x80066e <pxDelayedTaskList>
 534:	f0 91 6f 06 	lds	r31, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 538:	05 80       	ldd	r0, Z+5	; 0x05
 53a:	f6 81       	ldd	r31, Z+6	; 0x06
 53c:	e0 2d       	mov	r30, r0
 53e:	06 80       	ldd	r0, Z+6	; 0x06
 540:	f7 81       	ldd	r31, Z+7	; 0x07
 542:	e0 2d       	mov	r30, r0
 544:	82 81       	ldd	r24, Z+2	; 0x02
 546:	93 81       	ldd	r25, Z+3	; 0x03
 548:	90 93 4e 06 	sts	0x064E, r25	; 0x80064e <xNextTaskUnblockTime+0x1>
 54c:	80 93 4d 06 	sts	0x064D, r24	; 0x80064d <xNextTaskUnblockTime>
 550:	08 95       	ret

00000552 <prvDeleteTCB>:
 552:	cf 93       	push	r28
 554:	df 93       	push	r29
 556:	ec 01       	movw	r28, r24
 558:	8f 89       	ldd	r24, Y+23	; 0x17
 55a:	98 8d       	ldd	r25, Y+24	; 0x18
 55c:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
 560:	ce 01       	movw	r24, r28
 562:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	08 95       	ret

0000056c <prvInitialiseNewTask>:
 56c:	6f 92       	push	r6
 56e:	7f 92       	push	r7
 570:	8f 92       	push	r8
 572:	9f 92       	push	r9
 574:	af 92       	push	r10
 576:	bf 92       	push	r11
 578:	cf 92       	push	r12
 57a:	df 92       	push	r13
 57c:	ef 92       	push	r14
 57e:	0f 93       	push	r16
 580:	1f 93       	push	r17
 582:	cf 93       	push	r28
 584:	df 93       	push	r29
 586:	cd b7       	in	r28, 0x3d	; 61
 588:	de b7       	in	r29, 0x3e	; 62
 58a:	4c 01       	movw	r8, r24
 58c:	f5 01       	movw	r30, r10
 58e:	87 89       	ldd	r24, Z+23	; 0x17
 590:	90 8d       	ldd	r25, Z+24	; 0x18
 592:	21 50       	subi	r18, 0x01	; 1
 594:	31 09       	sbc	r19, r1
 596:	3c 01       	movw	r6, r24
 598:	62 0e       	add	r6, r18
 59a:	73 1e       	adc	r7, r19
 59c:	61 15       	cp	r22, r1
 59e:	71 05       	cpc	r23, r1
 5a0:	89 f4       	brne	.+34     	; 0x5c4 <prvInitialiseNewTask+0x58>
 5a2:	16 c0       	rjmp	.+44     	; 0x5d0 <prvInitialiseNewTask+0x64>
 5a4:	82 2f       	mov	r24, r18
 5a6:	90 e0       	ldi	r25, 0x00	; 0
 5a8:	fb 01       	movw	r30, r22
 5aa:	e8 0f       	add	r30, r24
 5ac:	f9 1f       	adc	r31, r25
 5ae:	30 81       	ld	r19, Z
 5b0:	d5 01       	movw	r26, r10
 5b2:	a8 0f       	add	r26, r24
 5b4:	b9 1f       	adc	r27, r25
 5b6:	59 96       	adiw	r26, 0x19	; 25
 5b8:	3c 93       	st	X, r19
 5ba:	80 81       	ld	r24, Z
 5bc:	88 23       	and	r24, r24
 5be:	29 f0       	breq	.+10     	; 0x5ca <prvInitialiseNewTask+0x5e>
 5c0:	2f 5f       	subi	r18, 0xFF	; 255
 5c2:	01 c0       	rjmp	.+2      	; 0x5c6 <prvInitialiseNewTask+0x5a>
 5c4:	20 e0       	ldi	r18, 0x00	; 0
 5c6:	28 30       	cpi	r18, 0x08	; 8
 5c8:	68 f3       	brcs	.-38     	; 0x5a4 <prvInitialiseNewTask+0x38>
 5ca:	f5 01       	movw	r30, r10
 5cc:	10 a2       	std	Z+32, r1	; 0x20
 5ce:	02 c0       	rjmp	.+4      	; 0x5d4 <prvInitialiseNewTask+0x68>
 5d0:	f5 01       	movw	r30, r10
 5d2:	11 8e       	std	Z+25, r1	; 0x19
 5d4:	f3 e0       	ldi	r31, 0x03	; 3
 5d6:	fe 15       	cp	r31, r14
 5d8:	20 f4       	brcc	.+8      	; 0x5e2 <prvInitialiseNewTask+0x76>
 5da:	0f 2e       	mov	r0, r31
 5dc:	f3 e0       	ldi	r31, 0x03	; 3
 5de:	ef 2e       	mov	r14, r31
 5e0:	f0 2d       	mov	r31, r0
 5e2:	f5 01       	movw	r30, r10
 5e4:	e6 8a       	std	Z+22, r14	; 0x16
 5e6:	c5 01       	movw	r24, r10
 5e8:	02 96       	adiw	r24, 0x02	; 2
 5ea:	0e 94 8d 00 	call	0x11a	; 0x11a <vListInitialiseItem>
 5ee:	c5 01       	movw	r24, r10
 5f0:	0c 96       	adiw	r24, 0x0c	; 12
 5f2:	0e 94 8d 00 	call	0x11a	; 0x11a <vListInitialiseItem>
 5f6:	f5 01       	movw	r30, r10
 5f8:	b1 86       	std	Z+9, r11	; 0x09
 5fa:	a0 86       	std	Z+8, r10	; 0x08
 5fc:	84 e0       	ldi	r24, 0x04	; 4
 5fe:	90 e0       	ldi	r25, 0x00	; 0
 600:	8e 19       	sub	r24, r14
 602:	91 09       	sbc	r25, r1
 604:	95 87       	std	Z+13, r25	; 0x0d
 606:	84 87       	std	Z+12, r24	; 0x0c
 608:	b3 8a       	std	Z+19, r11	; 0x13
 60a:	a2 8a       	std	Z+18, r10	; 0x12
 60c:	11 a2       	std	Z+33, r1	; 0x21
 60e:	12 a2       	std	Z+34, r1	; 0x22
 610:	13 a2       	std	Z+35, r1	; 0x23
 612:	14 a2       	std	Z+36, r1	; 0x24
 614:	15 a2       	std	Z+37, r1	; 0x25
 616:	a8 01       	movw	r20, r16
 618:	b4 01       	movw	r22, r8
 61a:	c3 01       	movw	r24, r6
 61c:	0e 94 37 01 	call	0x26e	; 0x26e <pxPortInitialiseStack>
 620:	f5 01       	movw	r30, r10
 622:	91 83       	std	Z+1, r25	; 0x01
 624:	80 83       	st	Z, r24
 626:	c1 14       	cp	r12, r1
 628:	d1 04       	cpc	r13, r1
 62a:	19 f0       	breq	.+6      	; 0x632 <prvInitialiseNewTask+0xc6>
 62c:	f6 01       	movw	r30, r12
 62e:	b1 82       	std	Z+1, r11	; 0x01
 630:	a0 82       	st	Z, r10
 632:	df 91       	pop	r29
 634:	cf 91       	pop	r28
 636:	1f 91       	pop	r17
 638:	0f 91       	pop	r16
 63a:	ef 90       	pop	r14
 63c:	df 90       	pop	r13
 63e:	cf 90       	pop	r12
 640:	bf 90       	pop	r11
 642:	af 90       	pop	r10
 644:	9f 90       	pop	r9
 646:	8f 90       	pop	r8
 648:	7f 90       	pop	r7
 64a:	6f 90       	pop	r6
 64c:	08 95       	ret

0000064e <prvInitialiseTaskLists>:
 64e:	cf 93       	push	r28
 650:	c0 e0       	ldi	r28, 0x00	; 0
 652:	10 c0       	rjmp	.+32     	; 0x674 <prvInitialiseTaskLists+0x26>
 654:	8c 2f       	mov	r24, r28
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	9c 01       	movw	r18, r24
 65a:	22 0f       	add	r18, r18
 65c:	33 1f       	adc	r19, r19
 65e:	22 0f       	add	r18, r18
 660:	33 1f       	adc	r19, r19
 662:	22 0f       	add	r18, r18
 664:	33 1f       	adc	r19, r19
 666:	82 0f       	add	r24, r18
 668:	93 1f       	adc	r25, r19
 66a:	8e 57       	subi	r24, 0x7E	; 126
 66c:	99 4f       	sbci	r25, 0xF9	; 249
 66e:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
 672:	cf 5f       	subi	r28, 0xFF	; 255
 674:	c4 30       	cpi	r28, 0x04	; 4
 676:	70 f3       	brcs	.-36     	; 0x654 <prvInitialiseTaskLists+0x6>
 678:	89 e7       	ldi	r24, 0x79	; 121
 67a:	96 e0       	ldi	r25, 0x06	; 6
 67c:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
 680:	80 e7       	ldi	r24, 0x70	; 112
 682:	96 e0       	ldi	r25, 0x06	; 6
 684:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
 688:	83 e6       	ldi	r24, 0x63	; 99
 68a:	96 e0       	ldi	r25, 0x06	; 6
 68c:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
 690:	8a e5       	ldi	r24, 0x5A	; 90
 692:	96 e0       	ldi	r25, 0x06	; 6
 694:	0e 94 7f 00 	call	0xfe	; 0xfe <vListInitialise>
 698:	89 e7       	ldi	r24, 0x79	; 121
 69a:	96 e0       	ldi	r25, 0x06	; 6
 69c:	90 93 6f 06 	sts	0x066F, r25	; 0x80066f <pxDelayedTaskList+0x1>
 6a0:	80 93 6e 06 	sts	0x066E, r24	; 0x80066e <pxDelayedTaskList>
 6a4:	80 e7       	ldi	r24, 0x70	; 112
 6a6:	96 e0       	ldi	r25, 0x06	; 6
 6a8:	90 93 6d 06 	sts	0x066D, r25	; 0x80066d <pxOverflowDelayedTaskList+0x1>
 6ac:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <pxOverflowDelayedTaskList>
 6b0:	cf 91       	pop	r28
 6b2:	08 95       	ret

000006b4 <prvAddNewTaskToReadyList>:
 6b4:	cf 93       	push	r28
 6b6:	df 93       	push	r29
 6b8:	ec 01       	movw	r28, r24
 6ba:	0f b6       	in	r0, 0x3f	; 63
 6bc:	f8 94       	cli
 6be:	0f 92       	push	r0
 6c0:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxCurrentNumberOfTasks>
 6c4:	8f 5f       	subi	r24, 0xFF	; 255
 6c6:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxCurrentNumberOfTasks>
 6ca:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 6ce:	90 91 a7 06 	lds	r25, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 6d2:	89 2b       	or	r24, r25
 6d4:	59 f4       	brne	.+22     	; 0x6ec <prvAddNewTaskToReadyList+0x38>
 6d6:	d0 93 a7 06 	sts	0x06A7, r29	; 0x8006a7 <pxCurrentTCB+0x1>
 6da:	c0 93 a6 06 	sts	0x06A6, r28	; 0x8006a6 <pxCurrentTCB>
 6de:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxCurrentNumberOfTasks>
 6e2:	81 30       	cpi	r24, 0x01	; 1
 6e4:	99 f4       	brne	.+38     	; 0x70c <prvAddNewTaskToReadyList+0x58>
 6e6:	0e 94 27 03 	call	0x64e	; 0x64e <prvInitialiseTaskLists>
 6ea:	10 c0       	rjmp	.+32     	; 0x70c <prvAddNewTaskToReadyList+0x58>
 6ec:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <xSchedulerRunning>
 6f0:	81 11       	cpse	r24, r1
 6f2:	0c c0       	rjmp	.+24     	; 0x70c <prvAddNewTaskToReadyList+0x58>
 6f4:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 6f8:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 6fc:	96 89       	ldd	r25, Z+22	; 0x16
 6fe:	8e 89       	ldd	r24, Y+22	; 0x16
 700:	89 17       	cp	r24, r25
 702:	20 f0       	brcs	.+8      	; 0x70c <prvAddNewTaskToReadyList+0x58>
 704:	d0 93 a7 06 	sts	0x06A7, r29	; 0x8006a7 <pxCurrentTCB+0x1>
 708:	c0 93 a6 06 	sts	0x06A6, r28	; 0x8006a6 <pxCurrentTCB>
 70c:	80 91 4f 06 	lds	r24, 0x064F	; 0x80064f <uxTaskNumber>
 710:	8f 5f       	subi	r24, 0xFF	; 255
 712:	80 93 4f 06 	sts	0x064F, r24	; 0x80064f <uxTaskNumber>
 716:	8e 89       	ldd	r24, Y+22	; 0x16
 718:	90 91 55 06 	lds	r25, 0x0655	; 0x800655 <uxTopReadyPriority>
 71c:	98 17       	cp	r25, r24
 71e:	10 f4       	brcc	.+4      	; 0x724 <prvAddNewTaskToReadyList+0x70>
 720:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <uxTopReadyPriority>
 724:	90 e0       	ldi	r25, 0x00	; 0
 726:	9c 01       	movw	r18, r24
 728:	22 0f       	add	r18, r18
 72a:	33 1f       	adc	r19, r19
 72c:	22 0f       	add	r18, r18
 72e:	33 1f       	adc	r19, r19
 730:	22 0f       	add	r18, r18
 732:	33 1f       	adc	r19, r19
 734:	82 0f       	add	r24, r18
 736:	93 1f       	adc	r25, r19
 738:	be 01       	movw	r22, r28
 73a:	6e 5f       	subi	r22, 0xFE	; 254
 73c:	7f 4f       	sbci	r23, 0xFF	; 255
 73e:	8e 57       	subi	r24, 0x7E	; 126
 740:	99 4f       	sbci	r25, 0xF9	; 249
 742:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
 746:	0f 90       	pop	r0
 748:	0f be       	out	0x3f, r0	; 63
 74a:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <xSchedulerRunning>
 74e:	88 23       	and	r24, r24
 750:	51 f0       	breq	.+20     	; 0x766 <prvAddNewTaskToReadyList+0xb2>
 752:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 756:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 75a:	96 89       	ldd	r25, Z+22	; 0x16
 75c:	8e 89       	ldd	r24, Y+22	; 0x16
 75e:	98 17       	cp	r25, r24
 760:	10 f4       	brcc	.+4      	; 0x766 <prvAddNewTaskToReadyList+0xb2>
 762:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
 766:	df 91       	pop	r29
 768:	cf 91       	pop	r28
 76a:	08 95       	ret

0000076c <prvCheckTasksWaitingTermination>:
 76c:	cf 93       	push	r28
 76e:	df 93       	push	r29
 770:	1c c0       	rjmp	.+56     	; 0x7aa <prvCheckTasksWaitingTermination+0x3e>
 772:	0f b6       	in	r0, 0x3f	; 63
 774:	f8 94       	cli
 776:	0f 92       	push	r0
 778:	e0 91 5f 06 	lds	r30, 0x065F	; 0x80065f <xTasksWaitingTermination+0x5>
 77c:	f0 91 60 06 	lds	r31, 0x0660	; 0x800660 <xTasksWaitingTermination+0x6>
 780:	c6 81       	ldd	r28, Z+6	; 0x06
 782:	d7 81       	ldd	r29, Z+7	; 0x07
 784:	ce 01       	movw	r24, r28
 786:	02 96       	adiw	r24, 0x02	; 2
 788:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 78c:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxCurrentNumberOfTasks>
 790:	81 50       	subi	r24, 0x01	; 1
 792:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxCurrentNumberOfTasks>
 796:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <uxDeletedTasksWaitingCleanUp>
 79a:	81 50       	subi	r24, 0x01	; 1
 79c:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <uxDeletedTasksWaitingCleanUp>
 7a0:	0f 90       	pop	r0
 7a2:	0f be       	out	0x3f, r0	; 63
 7a4:	ce 01       	movw	r24, r28
 7a6:	0e 94 a9 02 	call	0x552	; 0x552 <prvDeleteTCB>
 7aa:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <uxDeletedTasksWaitingCleanUp>
 7ae:	81 11       	cpse	r24, r1
 7b0:	e0 cf       	rjmp	.-64     	; 0x772 <prvCheckTasksWaitingTermination+0x6>
 7b2:	df 91       	pop	r29
 7b4:	cf 91       	pop	r28
 7b6:	08 95       	ret

000007b8 <prvIdleTask>:
 7b8:	0e 94 b6 03 	call	0x76c	; 0x76c <prvCheckTasksWaitingTermination>
 7bc:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <pxReadyTasksLists>
 7c0:	82 30       	cpi	r24, 0x02	; 2
 7c2:	d0 f3       	brcs	.-12     	; 0x7b8 <prvIdleTask>
 7c4:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
 7c8:	f7 cf       	rjmp	.-18     	; 0x7b8 <prvIdleTask>

000007ca <prvAddCurrentTaskToDelayedList>:
 7ca:	0f 93       	push	r16
 7cc:	1f 93       	push	r17
 7ce:	cf 93       	push	r28
 7d0:	df 93       	push	r29
 7d2:	ec 01       	movw	r28, r24
 7d4:	00 91 56 06 	lds	r16, 0x0656	; 0x800656 <xTickCount>
 7d8:	10 91 57 06 	lds	r17, 0x0657	; 0x800657 <xTickCount+0x1>
 7dc:	80 91 a6 06 	lds	r24, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 7e0:	90 91 a7 06 	lds	r25, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 7e4:	02 96       	adiw	r24, 0x02	; 2
 7e6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 7ea:	c0 0f       	add	r28, r16
 7ec:	d1 1f       	adc	r29, r17
 7ee:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 7f2:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 7f6:	d3 83       	std	Z+3, r29	; 0x03
 7f8:	c2 83       	std	Z+2, r28	; 0x02
 7fa:	c0 17       	cp	r28, r16
 7fc:	d1 07       	cpc	r29, r17
 7fe:	68 f4       	brcc	.+26     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
 800:	60 91 a6 06 	lds	r22, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 804:	70 91 a7 06 	lds	r23, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 808:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <pxOverflowDelayedTaskList>
 80c:	90 91 6d 06 	lds	r25, 0x066D	; 0x80066d <pxOverflowDelayedTaskList+0x1>
 810:	6e 5f       	subi	r22, 0xFE	; 254
 812:	7f 4f       	sbci	r23, 0xFF	; 255
 814:	0e 94 b2 00 	call	0x164	; 0x164 <vListInsert>
 818:	17 c0       	rjmp	.+46     	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 81a:	60 91 a6 06 	lds	r22, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 81e:	70 91 a7 06 	lds	r23, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 822:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <pxDelayedTaskList>
 826:	90 91 6f 06 	lds	r25, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 82a:	6e 5f       	subi	r22, 0xFE	; 254
 82c:	7f 4f       	sbci	r23, 0xFF	; 255
 82e:	0e 94 b2 00 	call	0x164	; 0x164 <vListInsert>
 832:	80 91 4d 06 	lds	r24, 0x064D	; 0x80064d <xNextTaskUnblockTime>
 836:	90 91 4e 06 	lds	r25, 0x064E	; 0x80064e <xNextTaskUnblockTime+0x1>
 83a:	c8 17       	cp	r28, r24
 83c:	d9 07       	cpc	r29, r25
 83e:	20 f4       	brcc	.+8      	; 0x848 <__DATA_REGION_LENGTH__+0x48>
 840:	d0 93 4e 06 	sts	0x064E, r29	; 0x80064e <xNextTaskUnblockTime+0x1>
 844:	c0 93 4d 06 	sts	0x064D, r28	; 0x80064d <xNextTaskUnblockTime>
 848:	df 91       	pop	r29
 84a:	cf 91       	pop	r28
 84c:	1f 91       	pop	r17
 84e:	0f 91       	pop	r16
 850:	08 95       	ret

00000852 <xTaskCreate>:
 852:	2f 92       	push	r2
 854:	3f 92       	push	r3
 856:	4f 92       	push	r4
 858:	5f 92       	push	r5
 85a:	6f 92       	push	r6
 85c:	7f 92       	push	r7
 85e:	8f 92       	push	r8
 860:	9f 92       	push	r9
 862:	af 92       	push	r10
 864:	bf 92       	push	r11
 866:	cf 92       	push	r12
 868:	df 92       	push	r13
 86a:	ef 92       	push	r14
 86c:	ff 92       	push	r15
 86e:	0f 93       	push	r16
 870:	1f 93       	push	r17
 872:	cf 93       	push	r28
 874:	df 93       	push	r29
 876:	3c 01       	movw	r6, r24
 878:	1b 01       	movw	r2, r22
 87a:	5a 01       	movw	r10, r20
 87c:	29 01       	movw	r4, r18
 87e:	ca 01       	movw	r24, r20
 880:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 884:	6c 01       	movw	r12, r24
 886:	89 2b       	or	r24, r25
 888:	71 f0       	breq	.+28     	; 0x8a6 <__stack+0x47>
 88a:	86 e2       	ldi	r24, 0x26	; 38
 88c:	90 e0       	ldi	r25, 0x00	; 0
 88e:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 892:	ec 01       	movw	r28, r24
 894:	89 2b       	or	r24, r25
 896:	19 f0       	breq	.+6      	; 0x89e <__stack+0x3f>
 898:	d8 8e       	std	Y+24, r13	; 0x18
 89a:	cf 8a       	std	Y+23, r12	; 0x17
 89c:	06 c0       	rjmp	.+12     	; 0x8aa <__stack+0x4b>
 89e:	c6 01       	movw	r24, r12
 8a0:	0e 94 7e 00 	call	0xfc	; 0xfc <vPortFree>
 8a4:	02 c0       	rjmp	.+4      	; 0x8aa <__stack+0x4b>
 8a6:	c0 e0       	ldi	r28, 0x00	; 0
 8a8:	d0 e0       	ldi	r29, 0x00	; 0
 8aa:	20 97       	sbiw	r28, 0x00	; 0
 8ac:	91 f0       	breq	.+36     	; 0x8d2 <__stack+0x73>
 8ae:	95 01       	movw	r18, r10
 8b0:	40 e0       	ldi	r20, 0x00	; 0
 8b2:	50 e0       	ldi	r21, 0x00	; 0
 8b4:	81 2c       	mov	r8, r1
 8b6:	91 2c       	mov	r9, r1
 8b8:	5e 01       	movw	r10, r28
 8ba:	67 01       	movw	r12, r14
 8bc:	e0 2e       	mov	r14, r16
 8be:	82 01       	movw	r16, r4
 8c0:	b1 01       	movw	r22, r2
 8c2:	c3 01       	movw	r24, r6
 8c4:	0e 94 b6 02 	call	0x56c	; 0x56c <prvInitialiseNewTask>
 8c8:	ce 01       	movw	r24, r28
 8ca:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <prvAddNewTaskToReadyList>
 8ce:	81 e0       	ldi	r24, 0x01	; 1
 8d0:	01 c0       	rjmp	.+2      	; 0x8d4 <__stack+0x75>
 8d2:	8f ef       	ldi	r24, 0xFF	; 255
 8d4:	df 91       	pop	r29
 8d6:	cf 91       	pop	r28
 8d8:	1f 91       	pop	r17
 8da:	0f 91       	pop	r16
 8dc:	ff 90       	pop	r15
 8de:	ef 90       	pop	r14
 8e0:	df 90       	pop	r13
 8e2:	cf 90       	pop	r12
 8e4:	bf 90       	pop	r11
 8e6:	af 90       	pop	r10
 8e8:	9f 90       	pop	r9
 8ea:	8f 90       	pop	r8
 8ec:	7f 90       	pop	r7
 8ee:	6f 90       	pop	r6
 8f0:	5f 90       	pop	r5
 8f2:	4f 90       	pop	r4
 8f4:	3f 90       	pop	r3
 8f6:	2f 90       	pop	r2
 8f8:	08 95       	ret

000008fa <vTaskStartScheduler>:
 8fa:	ef 92       	push	r14
 8fc:	ff 92       	push	r15
 8fe:	0f 93       	push	r16
 900:	0f 2e       	mov	r0, r31
 902:	fb e4       	ldi	r31, 0x4B	; 75
 904:	ef 2e       	mov	r14, r31
 906:	f6 e0       	ldi	r31, 0x06	; 6
 908:	ff 2e       	mov	r15, r31
 90a:	f0 2d       	mov	r31, r0
 90c:	00 e0       	ldi	r16, 0x00	; 0
 90e:	20 e0       	ldi	r18, 0x00	; 0
 910:	30 e0       	ldi	r19, 0x00	; 0
 912:	45 e5       	ldi	r20, 0x55	; 85
 914:	50 e0       	ldi	r21, 0x00	; 0
 916:	64 e6       	ldi	r22, 0x64	; 100
 918:	70 e0       	ldi	r23, 0x00	; 0
 91a:	8c ed       	ldi	r24, 0xDC	; 220
 91c:	93 e0       	ldi	r25, 0x03	; 3
 91e:	0e 94 29 04 	call	0x852	; 0x852 <xTaskCreate>
 922:	81 30       	cpi	r24, 0x01	; 1
 924:	81 f4       	brne	.+32     	; 0x946 <vTaskStartScheduler+0x4c>
 926:	f8 94       	cli
 928:	8f ef       	ldi	r24, 0xFF	; 255
 92a:	9f ef       	ldi	r25, 0xFF	; 255
 92c:	90 93 4e 06 	sts	0x064E, r25	; 0x80064e <xNextTaskUnblockTime+0x1>
 930:	80 93 4d 06 	sts	0x064D, r24	; 0x80064d <xNextTaskUnblockTime>
 934:	81 e0       	ldi	r24, 0x01	; 1
 936:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <xSchedulerRunning>
 93a:	10 92 57 06 	sts	0x0657, r1	; 0x800657 <xTickCount+0x1>
 93e:	10 92 56 06 	sts	0x0656, r1	; 0x800656 <xTickCount>
 942:	0e 94 a3 01 	call	0x346	; 0x346 <xPortStartScheduler>
 946:	0f 91       	pop	r16
 948:	ff 90       	pop	r15
 94a:	ef 90       	pop	r14
 94c:	08 95       	ret

0000094e <vTaskSuspendAll>:
 94e:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <uxSchedulerSuspended>
 952:	8f 5f       	subi	r24, 0xFF	; 255
 954:	80 93 4a 06 	sts	0x064A, r24	; 0x80064a <uxSchedulerSuspended>
 958:	08 95       	ret

0000095a <xTaskIncrementTick>:
 95a:	df 92       	push	r13
 95c:	ef 92       	push	r14
 95e:	ff 92       	push	r15
 960:	0f 93       	push	r16
 962:	1f 93       	push	r17
 964:	cf 93       	push	r28
 966:	df 93       	push	r29
 968:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <uxSchedulerSuspended>
 96c:	81 11       	cpse	r24, r1
 96e:	9d c0       	rjmp	.+314    	; 0xaaa <xTaskIncrementTick+0x150>
 970:	e0 90 56 06 	lds	r14, 0x0656	; 0x800656 <xTickCount>
 974:	f0 90 57 06 	lds	r15, 0x0657	; 0x800657 <xTickCount+0x1>
 978:	8f ef       	ldi	r24, 0xFF	; 255
 97a:	e8 1a       	sub	r14, r24
 97c:	f8 0a       	sbc	r15, r24
 97e:	f0 92 57 06 	sts	0x0657, r15	; 0x800657 <xTickCount+0x1>
 982:	e0 92 56 06 	sts	0x0656, r14	; 0x800656 <xTickCount>
 986:	e1 14       	cp	r14, r1
 988:	f1 04       	cpc	r15, r1
 98a:	b9 f4       	brne	.+46     	; 0x9ba <xTaskIncrementTick+0x60>
 98c:	80 91 6e 06 	lds	r24, 0x066E	; 0x80066e <pxDelayedTaskList>
 990:	90 91 6f 06 	lds	r25, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 994:	20 91 6c 06 	lds	r18, 0x066C	; 0x80066c <pxOverflowDelayedTaskList>
 998:	30 91 6d 06 	lds	r19, 0x066D	; 0x80066d <pxOverflowDelayedTaskList+0x1>
 99c:	30 93 6f 06 	sts	0x066F, r19	; 0x80066f <pxDelayedTaskList+0x1>
 9a0:	20 93 6e 06 	sts	0x066E, r18	; 0x80066e <pxDelayedTaskList>
 9a4:	90 93 6d 06 	sts	0x066D, r25	; 0x80066d <pxOverflowDelayedTaskList+0x1>
 9a8:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <pxOverflowDelayedTaskList>
 9ac:	80 91 50 06 	lds	r24, 0x0650	; 0x800650 <xNumOfOverflows>
 9b0:	8f 5f       	subi	r24, 0xFF	; 255
 9b2:	80 93 50 06 	sts	0x0650, r24	; 0x800650 <xNumOfOverflows>
 9b6:	0e 94 8a 02 	call	0x514	; 0x514 <prvResetNextTaskUnblockTime>
 9ba:	80 91 4d 06 	lds	r24, 0x064D	; 0x80064d <xNextTaskUnblockTime>
 9be:	90 91 4e 06 	lds	r25, 0x064E	; 0x80064e <xNextTaskUnblockTime+0x1>
 9c2:	e8 16       	cp	r14, r24
 9c4:	f9 06       	cpc	r15, r25
 9c6:	28 f4       	brcc	.+10     	; 0x9d2 <xTaskIncrementTick+0x78>
 9c8:	d1 2c       	mov	r13, r1
 9ca:	53 c0       	rjmp	.+166    	; 0xa72 <xTaskIncrementTick+0x118>
 9cc:	dd 24       	eor	r13, r13
 9ce:	d3 94       	inc	r13
 9d0:	01 c0       	rjmp	.+2      	; 0x9d4 <xTaskIncrementTick+0x7a>
 9d2:	d1 2c       	mov	r13, r1
 9d4:	e0 91 6e 06 	lds	r30, 0x066E	; 0x80066e <pxDelayedTaskList>
 9d8:	f0 91 6f 06 	lds	r31, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 9dc:	80 81       	ld	r24, Z
 9de:	81 11       	cpse	r24, r1
 9e0:	07 c0       	rjmp	.+14     	; 0x9f0 <xTaskIncrementTick+0x96>
 9e2:	8f ef       	ldi	r24, 0xFF	; 255
 9e4:	9f ef       	ldi	r25, 0xFF	; 255
 9e6:	90 93 4e 06 	sts	0x064E, r25	; 0x80064e <xNextTaskUnblockTime+0x1>
 9ea:	80 93 4d 06 	sts	0x064D, r24	; 0x80064d <xNextTaskUnblockTime>
 9ee:	41 c0       	rjmp	.+130    	; 0xa72 <xTaskIncrementTick+0x118>
 9f0:	e0 91 6e 06 	lds	r30, 0x066E	; 0x80066e <pxDelayedTaskList>
 9f4:	f0 91 6f 06 	lds	r31, 0x066F	; 0x80066f <pxDelayedTaskList+0x1>
 9f8:	05 80       	ldd	r0, Z+5	; 0x05
 9fa:	f6 81       	ldd	r31, Z+6	; 0x06
 9fc:	e0 2d       	mov	r30, r0
 9fe:	c6 81       	ldd	r28, Z+6	; 0x06
 a00:	d7 81       	ldd	r29, Z+7	; 0x07
 a02:	8a 81       	ldd	r24, Y+2	; 0x02
 a04:	9b 81       	ldd	r25, Y+3	; 0x03
 a06:	e8 16       	cp	r14, r24
 a08:	f9 06       	cpc	r15, r25
 a0a:	28 f4       	brcc	.+10     	; 0xa16 <xTaskIncrementTick+0xbc>
 a0c:	90 93 4e 06 	sts	0x064E, r25	; 0x80064e <xNextTaskUnblockTime+0x1>
 a10:	80 93 4d 06 	sts	0x064D, r24	; 0x80064d <xNextTaskUnblockTime>
 a14:	2e c0       	rjmp	.+92     	; 0xa72 <xTaskIncrementTick+0x118>
 a16:	8e 01       	movw	r16, r28
 a18:	0e 5f       	subi	r16, 0xFE	; 254
 a1a:	1f 4f       	sbci	r17, 0xFF	; 255
 a1c:	c8 01       	movw	r24, r16
 a1e:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 a22:	8c 89       	ldd	r24, Y+20	; 0x14
 a24:	9d 89       	ldd	r25, Y+21	; 0x15
 a26:	89 2b       	or	r24, r25
 a28:	21 f0       	breq	.+8      	; 0xa32 <xTaskIncrementTick+0xd8>
 a2a:	ce 01       	movw	r24, r28
 a2c:	0c 96       	adiw	r24, 0x0c	; 12
 a2e:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 a32:	8e 89       	ldd	r24, Y+22	; 0x16
 a34:	90 91 55 06 	lds	r25, 0x0655	; 0x800655 <uxTopReadyPriority>
 a38:	98 17       	cp	r25, r24
 a3a:	10 f4       	brcc	.+4      	; 0xa40 <xTaskIncrementTick+0xe6>
 a3c:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <uxTopReadyPriority>
 a40:	90 e0       	ldi	r25, 0x00	; 0
 a42:	9c 01       	movw	r18, r24
 a44:	22 0f       	add	r18, r18
 a46:	33 1f       	adc	r19, r19
 a48:	22 0f       	add	r18, r18
 a4a:	33 1f       	adc	r19, r19
 a4c:	22 0f       	add	r18, r18
 a4e:	33 1f       	adc	r19, r19
 a50:	82 0f       	add	r24, r18
 a52:	93 1f       	adc	r25, r19
 a54:	b8 01       	movw	r22, r16
 a56:	8e 57       	subi	r24, 0x7E	; 126
 a58:	99 4f       	sbci	r25, 0xF9	; 249
 a5a:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
 a5e:	9e 89       	ldd	r25, Y+22	; 0x16
 a60:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 a64:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 a68:	86 89       	ldd	r24, Z+22	; 0x16
 a6a:	98 17       	cp	r25, r24
 a6c:	08 f0       	brcs	.+2      	; 0xa70 <xTaskIncrementTick+0x116>
 a6e:	ae cf       	rjmp	.-164    	; 0x9cc <xTaskIncrementTick+0x72>
 a70:	b1 cf       	rjmp	.-158    	; 0x9d4 <xTaskIncrementTick+0x7a>
 a72:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 a76:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 a7a:	86 89       	ldd	r24, Z+22	; 0x16
 a7c:	90 e0       	ldi	r25, 0x00	; 0
 a7e:	fc 01       	movw	r30, r24
 a80:	ee 0f       	add	r30, r30
 a82:	ff 1f       	adc	r31, r31
 a84:	ee 0f       	add	r30, r30
 a86:	ff 1f       	adc	r31, r31
 a88:	ee 0f       	add	r30, r30
 a8a:	ff 1f       	adc	r31, r31
 a8c:	8e 0f       	add	r24, r30
 a8e:	9f 1f       	adc	r25, r31
 a90:	fc 01       	movw	r30, r24
 a92:	ee 57       	subi	r30, 0x7E	; 126
 a94:	f9 4f       	sbci	r31, 0xF9	; 249
 a96:	80 81       	ld	r24, Z
 a98:	82 30       	cpi	r24, 0x02	; 2
 a9a:	10 f0       	brcs	.+4      	; 0xaa0 <xTaskIncrementTick+0x146>
 a9c:	dd 24       	eor	r13, r13
 a9e:	d3 94       	inc	r13
 aa0:	80 91 51 06 	lds	r24, 0x0651	; 0x800651 <xYieldPending>
 aa4:	81 11       	cpse	r24, r1
 aa6:	0c c0       	rjmp	.+24     	; 0xac0 <xTaskIncrementTick+0x166>
 aa8:	0d c0       	rjmp	.+26     	; 0xac4 <xTaskIncrementTick+0x16a>
 aaa:	80 91 52 06 	lds	r24, 0x0652	; 0x800652 <xPendedTicks>
 aae:	90 91 53 06 	lds	r25, 0x0653	; 0x800653 <xPendedTicks+0x1>
 ab2:	01 96       	adiw	r24, 0x01	; 1
 ab4:	90 93 53 06 	sts	0x0653, r25	; 0x800653 <xPendedTicks+0x1>
 ab8:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <xPendedTicks>
 abc:	d1 2c       	mov	r13, r1
 abe:	02 c0       	rjmp	.+4      	; 0xac4 <xTaskIncrementTick+0x16a>
 ac0:	dd 24       	eor	r13, r13
 ac2:	d3 94       	inc	r13
 ac4:	8d 2d       	mov	r24, r13
 ac6:	df 91       	pop	r29
 ac8:	cf 91       	pop	r28
 aca:	1f 91       	pop	r17
 acc:	0f 91       	pop	r16
 ace:	ff 90       	pop	r15
 ad0:	ef 90       	pop	r14
 ad2:	df 90       	pop	r13
 ad4:	08 95       	ret

00000ad6 <xTaskResumeAll>:
 ad6:	0f 93       	push	r16
 ad8:	1f 93       	push	r17
 ada:	cf 93       	push	r28
 adc:	df 93       	push	r29
 ade:	0f b6       	in	r0, 0x3f	; 63
 ae0:	f8 94       	cli
 ae2:	0f 92       	push	r0
 ae4:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <uxSchedulerSuspended>
 ae8:	81 50       	subi	r24, 0x01	; 1
 aea:	80 93 4a 06 	sts	0x064A, r24	; 0x80064a <uxSchedulerSuspended>
 aee:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <uxSchedulerSuspended>
 af2:	81 11       	cpse	r24, r1
 af4:	5c c0       	rjmp	.+184    	; 0xbae <xTaskResumeAll+0xd8>
 af6:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxCurrentNumberOfTasks>
 afa:	81 11       	cpse	r24, r1
 afc:	33 c0       	rjmp	.+102    	; 0xb64 <xTaskResumeAll+0x8e>
 afe:	5a c0       	rjmp	.+180    	; 0xbb4 <xTaskResumeAll+0xde>
 b00:	e0 91 68 06 	lds	r30, 0x0668	; 0x800668 <xPendingReadyList+0x5>
 b04:	f0 91 69 06 	lds	r31, 0x0669	; 0x800669 <xPendingReadyList+0x6>
 b08:	c6 81       	ldd	r28, Z+6	; 0x06
 b0a:	d7 81       	ldd	r29, Z+7	; 0x07
 b0c:	ce 01       	movw	r24, r28
 b0e:	0c 96       	adiw	r24, 0x0c	; 12
 b10:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 b14:	8e 01       	movw	r16, r28
 b16:	0e 5f       	subi	r16, 0xFE	; 254
 b18:	1f 4f       	sbci	r17, 0xFF	; 255
 b1a:	c8 01       	movw	r24, r16
 b1c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
 b20:	8e 89       	ldd	r24, Y+22	; 0x16
 b22:	90 91 55 06 	lds	r25, 0x0655	; 0x800655 <uxTopReadyPriority>
 b26:	98 17       	cp	r25, r24
 b28:	10 f4       	brcc	.+4      	; 0xb2e <xTaskResumeAll+0x58>
 b2a:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <uxTopReadyPriority>
 b2e:	90 e0       	ldi	r25, 0x00	; 0
 b30:	9c 01       	movw	r18, r24
 b32:	22 0f       	add	r18, r18
 b34:	33 1f       	adc	r19, r19
 b36:	22 0f       	add	r18, r18
 b38:	33 1f       	adc	r19, r19
 b3a:	22 0f       	add	r18, r18
 b3c:	33 1f       	adc	r19, r19
 b3e:	82 0f       	add	r24, r18
 b40:	93 1f       	adc	r25, r19
 b42:	b8 01       	movw	r22, r16
 b44:	8e 57       	subi	r24, 0x7E	; 126
 b46:	99 4f       	sbci	r25, 0xF9	; 249
 b48:	0e 94 91 00 	call	0x122	; 0x122 <vListInsertEnd>
 b4c:	9e 89       	ldd	r25, Y+22	; 0x16
 b4e:	e0 91 a6 06 	lds	r30, 0x06A6	; 0x8006a6 <pxCurrentTCB>
 b52:	f0 91 a7 06 	lds	r31, 0x06A7	; 0x8006a7 <pxCurrentTCB+0x1>
 b56:	86 89       	ldd	r24, Z+22	; 0x16
 b58:	98 17       	cp	r25, r24
 b5a:	30 f0       	brcs	.+12     	; 0xb68 <xTaskResumeAll+0x92>
 b5c:	81 e0       	ldi	r24, 0x01	; 1
 b5e:	80 93 51 06 	sts	0x0651, r24	; 0x800651 <xYieldPending>
 b62:	02 c0       	rjmp	.+4      	; 0xb68 <xTaskResumeAll+0x92>
 b64:	c0 e0       	ldi	r28, 0x00	; 0
 b66:	d0 e0       	ldi	r29, 0x00	; 0
 b68:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <xPendingReadyList>
 b6c:	81 11       	cpse	r24, r1
 b6e:	c8 cf       	rjmp	.-112    	; 0xb00 <xTaskResumeAll+0x2a>
 b70:	cd 2b       	or	r28, r29
 b72:	11 f0       	breq	.+4      	; 0xb78 <xTaskResumeAll+0xa2>
 b74:	0e 94 8a 02 	call	0x514	; 0x514 <prvResetNextTaskUnblockTime>
 b78:	c0 91 52 06 	lds	r28, 0x0652	; 0x800652 <xPendedTicks>
 b7c:	d0 91 53 06 	lds	r29, 0x0653	; 0x800653 <xPendedTicks+0x1>
 b80:	20 97       	sbiw	r28, 0x00	; 0
 b82:	69 f0       	breq	.+26     	; 0xb9e <xTaskResumeAll+0xc8>
 b84:	0e 94 ad 04 	call	0x95a	; 0x95a <xTaskIncrementTick>
 b88:	88 23       	and	r24, r24
 b8a:	19 f0       	breq	.+6      	; 0xb92 <xTaskResumeAll+0xbc>
 b8c:	81 e0       	ldi	r24, 0x01	; 1
 b8e:	80 93 51 06 	sts	0x0651, r24	; 0x800651 <xYieldPending>
 b92:	21 97       	sbiw	r28, 0x01	; 1
 b94:	b9 f7       	brne	.-18     	; 0xb84 <xTaskResumeAll+0xae>
 b96:	10 92 53 06 	sts	0x0653, r1	; 0x800653 <xPendedTicks+0x1>
 b9a:	10 92 52 06 	sts	0x0652, r1	; 0x800652 <xPendedTicks>
 b9e:	80 91 51 06 	lds	r24, 0x0651	; 0x800651 <xYieldPending>
 ba2:	88 23       	and	r24, r24
 ba4:	31 f0       	breq	.+12     	; 0xbb2 <xTaskResumeAll+0xdc>
 ba6:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
 baa:	81 e0       	ldi	r24, 0x01	; 1
 bac:	03 c0       	rjmp	.+6      	; 0xbb4 <xTaskResumeAll+0xde>
 bae:	80 e0       	ldi	r24, 0x00	; 0
 bb0:	01 c0       	rjmp	.+2      	; 0xbb4 <xTaskResumeAll+0xde>
 bb2:	80 e0       	ldi	r24, 0x00	; 0
 bb4:	0f 90       	pop	r0
 bb6:	0f be       	out	0x3f, r0	; 63
 bb8:	df 91       	pop	r29
 bba:	cf 91       	pop	r28
 bbc:	1f 91       	pop	r17
 bbe:	0f 91       	pop	r16
 bc0:	08 95       	ret

00000bc2 <vTaskDelay>:
 bc2:	cf 93       	push	r28
 bc4:	df 93       	push	r29
 bc6:	ec 01       	movw	r28, r24
 bc8:	89 2b       	or	r24, r25
 bca:	49 f0       	breq	.+18     	; 0xbde <vTaskDelay+0x1c>
 bcc:	0e 94 a7 04 	call	0x94e	; 0x94e <vTaskSuspendAll>
 bd0:	60 e0       	ldi	r22, 0x00	; 0
 bd2:	ce 01       	movw	r24, r28
 bd4:	0e 94 e5 03 	call	0x7ca	; 0x7ca <prvAddCurrentTaskToDelayedList>
 bd8:	0e 94 6b 05 	call	0xad6	; 0xad6 <xTaskResumeAll>
 bdc:	01 c0       	rjmp	.+2      	; 0xbe0 <vTaskDelay+0x1e>
 bde:	80 e0       	ldi	r24, 0x00	; 0
 be0:	81 11       	cpse	r24, r1
 be2:	02 c0       	rjmp	.+4      	; 0xbe8 <vTaskDelay+0x26>
 be4:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
 be8:	df 91       	pop	r29
 bea:	cf 91       	pop	r28
 bec:	08 95       	ret

00000bee <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 bee:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <uxSchedulerSuspended>
 bf2:	88 23       	and	r24, r24
 bf4:	21 f0       	breq	.+8      	; 0xbfe <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 bf6:	81 e0       	ldi	r24, 0x01	; 1
 bf8:	80 93 51 06 	sts	0x0651, r24	; 0x800651 <xYieldPending>
 bfc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 bfe:	10 92 51 06 	sts	0x0651, r1	; 0x800651 <xYieldPending>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 c02:	20 91 55 06 	lds	r18, 0x0655	; 0x800655 <uxTopReadyPriority>
 c06:	01 c0       	rjmp	.+2      	; 0xc0a <vTaskSwitchContext+0x1c>
 c08:	21 50       	subi	r18, 0x01	; 1
 c0a:	82 2f       	mov	r24, r18
 c0c:	90 e0       	ldi	r25, 0x00	; 0
 c0e:	fc 01       	movw	r30, r24
 c10:	ee 0f       	add	r30, r30
 c12:	ff 1f       	adc	r31, r31
 c14:	ee 0f       	add	r30, r30
 c16:	ff 1f       	adc	r31, r31
 c18:	ee 0f       	add	r30, r30
 c1a:	ff 1f       	adc	r31, r31
 c1c:	e8 0f       	add	r30, r24
 c1e:	f9 1f       	adc	r31, r25
 c20:	ee 57       	subi	r30, 0x7E	; 126
 c22:	f9 4f       	sbci	r31, 0xF9	; 249
 c24:	30 81       	ld	r19, Z
 c26:	33 23       	and	r19, r19
 c28:	79 f3       	breq	.-34     	; 0xc08 <vTaskSwitchContext+0x1a>
 c2a:	ac 01       	movw	r20, r24
 c2c:	44 0f       	add	r20, r20
 c2e:	55 1f       	adc	r21, r21
 c30:	44 0f       	add	r20, r20
 c32:	55 1f       	adc	r21, r21
 c34:	44 0f       	add	r20, r20
 c36:	55 1f       	adc	r21, r21
 c38:	48 0f       	add	r20, r24
 c3a:	59 1f       	adc	r21, r25
 c3c:	df 01       	movw	r26, r30
 c3e:	01 80       	ldd	r0, Z+1	; 0x01
 c40:	f2 81       	ldd	r31, Z+2	; 0x02
 c42:	e0 2d       	mov	r30, r0
 c44:	02 80       	ldd	r0, Z+2	; 0x02
 c46:	f3 81       	ldd	r31, Z+3	; 0x03
 c48:	e0 2d       	mov	r30, r0
 c4a:	12 96       	adiw	r26, 0x02	; 2
 c4c:	fc 93       	st	X, r31
 c4e:	ee 93       	st	-X, r30
 c50:	11 97       	sbiw	r26, 0x01	; 1
 c52:	4b 57       	subi	r20, 0x7B	; 123
 c54:	59 4f       	sbci	r21, 0xF9	; 249
 c56:	e4 17       	cp	r30, r20
 c58:	f5 07       	cpc	r31, r21
 c5a:	29 f4       	brne	.+10     	; 0xc66 <vTaskSwitchContext+0x78>
 c5c:	42 81       	ldd	r20, Z+2	; 0x02
 c5e:	53 81       	ldd	r21, Z+3	; 0x03
 c60:	fd 01       	movw	r30, r26
 c62:	52 83       	std	Z+2, r21	; 0x02
 c64:	41 83       	std	Z+1, r20	; 0x01
 c66:	fc 01       	movw	r30, r24
 c68:	ee 0f       	add	r30, r30
 c6a:	ff 1f       	adc	r31, r31
 c6c:	ee 0f       	add	r30, r30
 c6e:	ff 1f       	adc	r31, r31
 c70:	ee 0f       	add	r30, r30
 c72:	ff 1f       	adc	r31, r31
 c74:	8e 0f       	add	r24, r30
 c76:	9f 1f       	adc	r25, r31
 c78:	fc 01       	movw	r30, r24
 c7a:	ee 57       	subi	r30, 0x7E	; 126
 c7c:	f9 4f       	sbci	r31, 0xF9	; 249
 c7e:	01 80       	ldd	r0, Z+1	; 0x01
 c80:	f2 81       	ldd	r31, Z+2	; 0x02
 c82:	e0 2d       	mov	r30, r0
 c84:	86 81       	ldd	r24, Z+6	; 0x06
 c86:	97 81       	ldd	r25, Z+7	; 0x07
 c88:	90 93 a7 06 	sts	0x06A7, r25	; 0x8006a7 <pxCurrentTCB+0x1>
 c8c:	80 93 a6 06 	sts	0x06A6, r24	; 0x8006a6 <pxCurrentTCB>
 c90:	20 93 55 06 	sts	0x0655, r18	; 0x800655 <uxTopReadyPriority>
 c94:	08 95       	ret

00000c96 <_exit>:
 c96:	f8 94       	cli

00000c98 <__stop_program>:
 c98:	ff cf       	rjmp	.-2      	; 0xc98 <__stop_program>
